# üîí Seguran√ßa e Prote√ß√£o Anti-Fraude

## üõ°Ô∏è Arquitetura de Seguran√ßa: 99.9% de Prote√ß√£o

### Defense in Depth - 7 Camadas de Prote√ß√£o

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. DDoS Protection (Layer 3/4)        ‚îÇ ‚Üê Volumetric attacks
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2. WAF Rules (Layer 7)                ‚îÇ ‚Üê Application attacks
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3. Bot Management Score                ‚îÇ ‚Üê ML detection
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4. Signature Verification              ‚îÇ ‚Üê Cryptographic auth
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  5. Payment Validation                  ‚îÇ ‚Üê Business logic
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  6. Rate Limiting                       ‚îÇ ‚Üê Resource control
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  7. Origin Shield                       ‚îÇ ‚Üê Last defense
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## ü§ñ Detec√ß√£o de Bots com ML

### Algoritmo de Detec√ß√£o Multi-Camada

```python
class AdvancedBotDetector:
    def __init__(self):
        self.models = {
            'isolation_forest': IsolationForest(contamination=0.001),
            'catboost': CatBoostClassifier(),
            'neural_network': self.load_nn_model(),
            'rule_based': RuleBasedDetector()
        }
        
    def detect(self, request):
        scores = {}
        
        # 1. An√°lise de Timing (30% peso)
        scores['timing'] = self.analyze_timing(request)
        
        # 2. Padr√µes Comportamentais (30% peso)
        scores['behavioral'] = self.analyze_behavior(request)
        
        # 3. Network Fingerprinting (20% peso)
        scores['network'] = self.analyze_network(request)
        
        # 4. ML Classification (20% peso)
        scores['ml'] = self.run_ml_models(request)
        
        # Weighted average
        final_score = (
            scores['timing'] * 0.3 +
            scores['behavioral'] * 0.3 +
            scores['network'] * 0.2 +
            scores['ml'] * 0.2
        )
        
        return {
            'is_bot': final_score > 0.7,
            'confidence': final_score,
            'breakdown': scores
        }
```

### Features de Detec√ß√£o

| Categoria | Feature | Peso | Bot Indicator |
|-----------|---------|------|---------------|
| **Timing** | Request interval < 100ms | Alto | ‚úì |
| **Timing** | Consistent intervals | Alto | ‚úì |
| **Behavior** | No mouse movement | M√©dio | ‚úì |
| **Behavior** | Linear navigation | Alto | ‚úì |
| **Network** | Datacenter IP | Alto | ‚úì |
| **Network** | No referrer | M√©dio | ‚úì |
| **Headers** | Missing common headers | Alto | ‚úì |
| **TLS** | Uncommon JA3 hash | M√©dio | ‚úì |

## üö¶ Rate Limiting Avan√ßado

### Implementa√ß√£o de Token Bucket

```javascript
class DistributedRateLimiter {
    constructor(redis) {
        this.redis = redis;
        this.configs = {
            'free': {
                capacity: 100,
                refillRate: 1,  // tokens/segundo
                cost: 1
            },
            'basic': {
                capacity: 1000,
                refillRate: 10,
                cost: 1
            },
            'premium': {
                capacity: 10000,
                refillRate: 100,
                cost: 0.5
            }
        };
    }
    
    async checkLimit(clientId, tier = 'free') {
        const config = this.configs[tier];
        const key = `ratelimit:${clientId}`;
        
        // Lua script para opera√ß√£o at√¥mica
        const luaScript = `
            local key = KEYS[1]
            local capacity = tonumber(ARGV[1])
            local refill_rate = tonumber(ARGV[2])
            local cost = tonumber(ARGV[3])
            local now = tonumber(ARGV[4])
            
            local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
            local tokens = tonumber(bucket[1]) or capacity
            local last_refill = tonumber(bucket[2]) or now
            
            -- Calcular tokens a adicionar
            local elapsed = now - last_refill
            local tokens_to_add = elapsed * refill_rate / 1000
            tokens = math.min(capacity, tokens + tokens_to_add)
            
            if tokens >= cost then
                tokens = tokens - cost
                redis.call('HMSET', key, 
                    'tokens', tokens, 
                    'last_refill', now)
                redis.call('EXPIRE', key, 3600)
                return {1, tokens}
            else
                return {0, tokens}
            end
        `;
        
        const result = await this.redis.eval(
            luaScript, 1, key,
            config.capacity,
            config.refillRate,
            config.cost,
            Date.now()
        );
        
        return {
            allowed: result[0] === 1,
            remaining: result[1]
        };
    }
}
```

### Configura√ß√µes por Tipo de Bot

| Bot Type | RPS Limit | Burst | Window | Action on Exceed |
|----------|-----------|-------|--------|------------------|
| **Verified Partner** | 1000 | 5000 | 1s | Log only |
| **Paid Crawler** | 100 | 500 | 1s | Throttle |
| **Free Tier** | 10 | 50 | 1s | 429 + Backoff |
| **Unknown** | 1 | 5 | 1s | 403 Block |
| **Suspicious** | 0.1 | 1 | 10s | IP Ban |

## üîê Preven√ß√£o de Fraudes

### Sistema de Detec√ß√£o de Anomalias

```python
class FraudDetectionSystem:
    def __init__(self):
        self.isolation_forest = IsolationForest(
            n_estimators=100,
            contamination=0.001,
            random_state=42
        )
        self.threshold_rules = {
            'velocity': 1000,  # requests/minute
            'geographic_variance': 5,  # countries/hour
            'cost_spike': 10,  # x normal spending
            'pattern_deviation': 3  # standard deviations
        }
    
    def detect_anomalies(self, bot_activity):
        features = self.extract_features(bot_activity)
        
        # 1. Isolation Forest para anomalias
        anomaly_score = self.isolation_forest.decision_function([features])[0]
        
        # 2. Regras de threshold
        violations = []
        if features['requests_per_minute'] > self.threshold_rules['velocity']:
            violations.append('velocity_exceeded')
        
        if features['unique_countries'] > self.threshold_rules['geographic_variance']:
            violations.append('geographic_anomaly')
        
        # 3. An√°lise de padr√µes
        pattern_score = self.analyze_patterns(bot_activity)
        
        risk_level = self.calculate_risk_level(
            anomaly_score, violations, pattern_score
        )
        
        return {
            'risk_level': risk_level,  # low, medium, high, critical
            'anomaly_score': anomaly_score,
            'violations': violations,
            'recommended_action': self.get_recommended_action(risk_level)
        }
```

### Indicadores de Fraude

```
üî¥ ALTA PROBABILIDADE DE FRAUDE
‚îú‚îÄ‚îÄ M√∫ltiplas geolocaliza√ß√µes simult√¢neas
‚îú‚îÄ‚îÄ Padr√£o de requests imposs√≠vel (>1000 req/s)
‚îú‚îÄ‚îÄ Tentativas de bypass de autentica√ß√£o
‚îú‚îÄ‚îÄ Headers inconsistentes
‚îî‚îÄ‚îÄ Payment tokens reutilizados

üü° M√âDIA PROBABILIDADE
‚îú‚îÄ‚îÄ Spike s√∫bito de consumo (>10x normal)
‚îú‚îÄ‚îÄ Novos User-Agents frequentes
‚îú‚îÄ‚îÄ Requests de IPs suspeitos
‚îî‚îÄ‚îÄ Timing patterns artificiais

üü¢ BAIXA PROBABILIDADE
‚îú‚îÄ‚îÄ Comportamento consistente
‚îú‚îÄ‚îÄ Autentica√ß√£o v√°lida
‚îú‚îÄ‚îÄ Pagamentos regulares
‚îî‚îÄ‚îÄ Padr√µes humanos detectados
```

## üõë Mitiga√ß√£o de Ataques DDoS

### Estrat√©gias por Tipo de Ataque

| Tipo de Ataque | Mitiga√ß√£o | Efic√°cia |
|----------------|-----------|----------|
| **Volumetric (L3/4)** | Rate limiting + Blackholing | 99.9% |
| **Application (L7)** | WAF + Challenge pages | 99.5% |
| **Slowloris** | Connection limits + Timeouts | 98% |
| **Amplification** | IP reputation + Filtering | 99% |
| **Bot Swarm** | ML detection + Fingerprinting | 97% |

### Implementa√ß√£o de Prote√ß√£o

```nginx
# Nginx configuration for DDoS protection
http {
    # Rate limiting zones
    limit_req_zone $binary_remote_addr zone=global:10m rate=10r/s;
    limit_req_zone $bot_identifier zone=bot:10m rate=100r/s;
    limit_conn_zone $binary_remote_addr zone=addr:10m;
    
    # Connection limits
    limit_conn addr 10;
    
    server {
        # Apply rate limiting
        limit_req zone=global burst=20 nodelay;
        
        # Bot-specific limits
        if ($verified_bot = "1") {
            limit_req zone=bot burst=200 nodelay;
        }
        
        # Geo-blocking suspicious regions
        if ($geoip_country_code ~ "XX|YY|ZZ") {
            return 403;
        }
        
        # Challenge suspicious requests
        if ($suspicious_score > 80) {
            return 302 /challenge?return=$request_uri;
        }
    }
}
```

## üîë Seguran√ßa de JWT e Autentica√ß√£o

### Best Practices Implementation

```javascript
class SecureJWTManager {
    constructor() {
        this.algorithm = 'RS256';  // Never use HS256
        this.keyRotationDays = 90;
        this.tokenExpiry = 900;  // 15 minutes
    }
    
    generateToken(payload) {
        const token = jwt.sign(
            {
                ...payload,
                jti: uuid.v4(),  // Unique ID
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + this.tokenExpiry,
                iss: 'pay-per-crawl-api',
                aud: payload.bot_id
            },
            this.privateKey,
            { algorithm: this.algorithm }
        );
        
        // Store token hash for revocation
        this.storeTokenHash(token);
        
        return token;
    }
    
    verifyToken(token) {
        try {
            // Check if revoked
            if (await this.isRevoked(token)) {
                throw new Error('Token revoked');
            }
            
            // Verify signature and claims
            const decoded = jwt.verify(token, this.publicKey, {
                algorithms: [this.algorithm],
                issuer: 'pay-per-crawl-api',
                maxAge: '15m'
            });
            
            // Additional checks
            if (!decoded.jti || !decoded.bot_id) {
                throw new Error('Missing required claims');
            }
            
            return decoded;
            
        } catch (error) {
            this.logSecurityEvent('jwt_verification_failed', { error });
            throw error;
        }
    }
}
```

## üìä Monitoramento de Seguran√ßa

### Dashboard de M√©tricas

```javascript
const securityMetrics = {
    // Real-time metrics
    'blocked_requests': new Counter('security_blocked_total'),
    'fraud_attempts': new Counter('fraud_attempts_total'),
    'auth_failures': new Counter('auth_failures_total'),
    'ddos_mitigated': new Counter('ddos_mitigated_total'),
    
    // Histograms
    'detection_latency': new Histogram('detection_latency_ms'),
    'risk_scores': new Histogram('risk_score_distribution'),
    
    // Gauges
    'active_threats': new Gauge('active_threats_current'),
    'suspicious_ips': new Gauge('suspicious_ips_tracked')
};
```

### Alertas Cr√≠ticos

```yaml
alerts:
  - name: HighFraudRate
    expr: rate(fraud_attempts_total[5m]) > 10
    severity: critical
    action: block_and_investigate
    
  - name: DDoSDetected
    expr: rate(requests_total[1m]) > 10000
    severity: critical
    action: enable_under_attack_mode
    
  - name: AuthenticationSpike
    expr: rate(auth_failures_total[5m]) > 100
    severity: warning
    action: investigate_source
    
  - name: UnusualSpending
    expr: increase(credits_consumed[1h]) > 1000
    severity: warning
    action: verify_with_customer
```

## üéØ Resposta a Incidentes

### Playbook de Seguran√ßa

#### 1. Detec√ß√£o de Fraude
```
1. Identificar padr√£o an√¥malo
2. Isolar conta/IP afetado
3. Analisar logs hist√≥ricos
4. Determinar se √© falso positivo
5. Se confirmado:
   - Bloquear imediatamente
   - Reverter transa√ß√µes
   - Notificar afetados
   - Documentar incidente
```

#### 2. Ataque DDoS
```
1. Ativar modo "Under Attack"
2. Aumentar rate limits
3. Habilitar CAPTCHA
4. Analisar origem do ataque
5. Implementar bloqueio geogr√°fico se necess√°rio
6. Escalar para CDN provider
7. Documentar e reportar
```

## üî¨ Testes de Seguran√ßa

### Checklist de Penetration Testing

- [ ] SQL Injection em par√¢metros
- [ ] XSS em responses
- [ ] CSRF em endpoints cr√≠ticos
- [ ] Rate limiting bypass
- [ ] JWT manipulation
- [ ] Payment validation bypass
- [ ] Bot detection evasion
- [ ] DDoS resistance
- [ ] API key leakage
- [ ] Privilege escalation

## Performance vs Seguran√ßa

### Trade-offs e Otimiza√ß√µes

| Medida de Seguran√ßa | Lat√™ncia Adicional | Impacto Performance | Valor |
|---------------------|-------------------|---------------------|-------|
| **Bot Score ML** | +50Œºs | M√≠nimo | Alto |
| **Crypto Verification** | +200Œºs | Baixo | Cr√≠tico |
| **Rate Limiting** | +10Œºs | M√≠nimo | Alto |
| **WAF Rules** | +100Œºs | Baixo | Alto |
| **Full Request Logging** | +500Œºs | M√©dio | M√©dio |
| **Deep Packet Inspection** | +2ms | Alto | Situacional |

## Pr√≥ximos Passos

Seguran√ßa implementada? Continue com:
- üéØ [Guia de Decis√£o](./08-guia-decisao.md)
- üîó [Recursos e Refer√™ncias](./09-recursos-referencias.md)

---

üîí **Lembre-se**: Seguran√ßa n√£o √© um produto, √© um processo cont√≠nuo!