# Vulnerability Management - Projetos Pr√°ticos para Portf√≥lio

## √çndice
- [Introdu√ß√£o](#introdu√ß√£o)
- [Fundamentos de Vulnerability Management](#fundamentos-de-vulnerability-management)
- [Plataformas Principais](#plataformas-principais)
- [Projeto Pr√°tico: Tenable Vulnerability Management](#projeto-pr√°tico-tenable-vulnerability-management)
- [Cyber Range Environment](#cyber-range-environment)
- [Metodologia de Vulnerability Assessment](#metodologia-de-vulnerability-assessment)
- [Automa√ß√£o e Integra√ß√£o](#automa√ß√£o-e-integra√ß√£o)
- [Relat√≥rios e M√©tricas](#relat√≥rios-e-m√©tricas)
- [Documenta√ß√£o de Projetos](#documenta√ß√£o-de-projetos)

## Introdu√ß√£o

**Vulnerability Management** √© uma disciplina cr√≠tica em seguran√ßa cibern√©tica que envolve identifica√ß√£o, avalia√ß√£o, prioriza√ß√£o e remedia√ß√£o de vulnerabilidades em sistemas e aplica√ß√µes. √â uma das √°reas mais demandadas no mercado, presente em praticamente todas as organiza√ß√µes.

### Import√¢ncia Strategic

```
üéØ Business Impact:
   - Redu√ß√£o de superf√≠cie de ataque
   - Compliance com regulamenta√ß√µes
   - Prote√ß√£o de dados sens√≠veis
   - Continuidade de neg√≥cios
   - Gest√£o de risco cibern√©tico

üìä Market Demand:
   - 100% das organiza√ß√µes enterprise
   - Crescimento de 25% ao ano
   - Sal√°rios acima da m√©dia de seguran√ßa
   - Progress√£o para roles de lideran√ßa
```

## Fundamentos de Vulnerability Management

### Ciclo de Vida de Vulnerabilidades

```
1. üîç Discovery & Asset Inventory
   - Network discovery
   - Asset classification
   - Service enumeration
   - Software inventory

2. üìä Vulnerability Assessment
   - Automated scanning
   - Manual testing
   - Threat intelligence correlation
   - Risk scoring

3. üéØ Prioritization & Risk Analysis
   - CVSS scoring
   - Business impact assessment
   - Threat landscape analysis
   - Exploit availability

4. üîß Remediation Planning
   - Patch management
   - Compensating controls
   - Timeline definition
   - Resource allocation

5. ‚úÖ Verification & Validation
   - Re-scanning
   - Penetration testing
   - Compliance validation
   - Continuous monitoring

6. üìà Reporting & Metrics
   - Executive dashboards
   - Technical reports
   - Trend analysis
   - KPI tracking
```

### Metodologias e Frameworks

**NIST Cybersecurity Framework:**
```
Identify ‚Üí Protect ‚Üí Detect ‚Üí Respond ‚Üí Recover
```

**OWASP Testing Guide:**
```
- Information Gathering
- Configuration Management
- Authentication Testing
- Session Management
- Input Validation
- Error Handling
- Cryptography
- Business Logic
- Client-side Testing
```

**PTES (Penetration Testing Execution Standard):**
```
Pre-engagement ‚Üí Intelligence ‚Üí Threat Modeling ‚Üí Vulnerability Analysis ‚Üí Exploitation ‚Üí Post-Exploitation ‚Üí Reporting
```

## Plataformas Principais

### Qualys vs Tenable

**Qualys VMDR:**
```
‚úÖ Strengths:
   - Cloud-native architecture
   - Integrated compliance
   - VMDR (Detect + Respond)
   - Global scanning infrastructure
   - Extensive vulnerability database

üìä Use Cases:
   - Large enterprise environments
   - Multi-cloud deployments
   - Compliance-heavy industries
   - Global organizations
```

**Tenable.io:**
```
‚úÖ Strengths:
   - Comprehensive asset discovery
   - Advanced analytics
   - Cloud security posture
   - Container scanning
   - Industrial/IoT support

üìä Use Cases:
   - Hybrid environments
   - DevOps integration
   - OT/IoT environments
   - Risk-based prioritization
```

### Outras Ferramentas Relevantes

**Open Source:**
- **OpenVAS**: Comprehensive vulnerability scanner
- **Nuclei**: Fast, template-based scanner
- **Nmap**: Network discovery and service detection
- **Nikto**: Web application scanner

**Commercial:**
- **Rapid7 InsightVM**: Vulnerability management with analytics
- **Acunetix**: Web application security testing
- **Burp Suite Enterprise**: Automated web app scanning
- **Checkmarx**: Static application security testing (SAST)

## Projeto Pr√°tico: Tenable Vulnerability Management

### Ambiente do Laborat√≥rio

**Infrastructure Setup:**
```
üèóÔ∏è Azure Cloud Environment:
   - Windows Server 2019 (Domain Controller)
   - Windows Server 2016 (Web Server)
   - Windows 10 Workstations (3x)
   - Ubuntu Server 20.04 (Database)
   - CentOS 8 (Application Server)

üîß Tenable Components:
   - Tenable.io platform
   - Nessus scanners (multiple)
   - Agent deployment
   - API integration
```

**Network Architecture:**
```
Internet
    ‚îÇ
    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Azure Cloud   ‚îÇ
‚îÇ     Network     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ
    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   DMZ Subnet    ‚îÇ    ‚îÇ  Internal Net   ‚îÇ    ‚îÇ  Database Net   ‚îÇ
‚îÇ (Web Servers)   ‚îÇ    ‚îÇ  (Workstations) ‚îÇ    ‚îÇ   (DB Servers)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ                      ‚îÇ                      ‚îÇ
    ‚ñº                      ‚ñº                      ‚ñº
[Nessus Scanner]      [Nessus Agents]       [Nessus Scanner]
```

### Implementa√ß√£o Hands-On

**1. Asset Discovery and Inventory:**
```python
#!/usr/bin/env python3
"""
Tenable Asset Discovery Script
Automates network discovery and asset inventory
"""

import requests
import json
from datetime import datetime
import csv

class TenableAssetManager:
    def __init__(self, access_key, secret_key):
        self.access_key = access_key
        self.secret_key = secret_key
        self.base_url = "https://cloud.tenable.com"
        self.headers = {
            'X-ApiKeys': f'accessKey={access_key}; secretKey={secret_key}',
            'Content-Type': 'application/json'
        }

    def discover_assets(self, network_range):
        """Perform network discovery scan"""
        scan_data = {
            "uuid": "731a8e52-3ea6-a291-ec0a-d2ff0619c19d7bd788d6",  # Discovery template
            "settings": {
                "name": f"Asset Discovery - {datetime.now().strftime('%Y%m%d')}",
                "description": "Automated asset discovery scan",
                "text_targets": network_range,
                "launch": "ONETIME"
            }
        }

        response = requests.post(
            f"{self.base_url}/scans",
            headers=self.headers,
            json=scan_data
        )

        if response.status_code == 200:
            scan_id = response.json()['scan']['id']
            print(f"Discovery scan created: {scan_id}")
            return scan_id
        else:
            print(f"Error creating scan: {response.text}")
            return None

    def launch_scan(self, scan_id):
        """Launch the discovery scan"""
        response = requests.post(
            f"{self.base_url}/scans/{scan_id}/launch",
            headers=self.headers
        )

        if response.status_code == 200:
            print(f"Scan {scan_id} launched successfully")
            return True
        else:
            print(f"Error launching scan: {response.text}")
            return False

    def get_scan_status(self, scan_id):
        """Check scan status"""
        response = requests.get(
            f"{self.base_url}/scans/{scan_id}",
            headers=self.headers
        )

        if response.status_code == 200:
            status = response.json()['info']['status']
            return status
        else:
            return None

    def export_assets(self, scan_id, format='csv'):
        """Export discovered assets"""
        export_data = {
            "format": format,
            "chapters": "vuln_hosts_summary"
        }

        response = requests.post(
            f"{self.base_url}/scans/{scan_id}/export",
            headers=self.headers,
            json=export_data
        )

        if response.status_code == 200:
            export_uuid = response.json()['token']
            print(f"Export initiated: {export_uuid}")
            return export_uuid
        else:
            print(f"Error initiating export: {response.text}")
            return None

    def download_report(self, scan_id, export_uuid):
        """Download the exported report"""
        response = requests.get(
            f"{self.base_url}/scans/{scan_id}/export/{export_uuid}/download",
            headers=self.headers
        )

        if response.status_code == 200:
            filename = f"asset_discovery_{datetime.now().strftime('%Y%m%d')}.csv"
            with open(filename, 'wb') as f:
                f.write(response.content)
            print(f"Report downloaded: {filename}")
            return filename
        else:
            print(f"Error downloading report: {response.text}")
            return None

    def create_asset_inventory(self, csv_file):
        """Process CSV and create structured asset inventory"""
        assets = []

        with open(csv_file, 'r') as file:
            reader = csv.DictReader(file)
            for row in reader:
                asset = {
                    'hostname': row.get('NetBIOS Name', 'Unknown'),
                    'ip_address': row.get('Host', ''),
                    'operating_system': row.get('Operating System', 'Unknown'),
                    'critical_vulns': int(row.get('Critical', 0)),
                    'high_vulns': int(row.get('High', 0)),
                    'medium_vulns': int(row.get('Medium', 0)),
                    'low_vulns': int(row.get('Low', 0)),
                    'risk_score': self.calculate_risk_score(row)
                }
                assets.append(asset)

        # Sort by risk score
        assets.sort(key=lambda x: x['risk_score'], reverse=True)
        return assets

    def calculate_risk_score(self, vuln_data):
        """Calculate custom risk score based on vulnerability severity"""
        critical = int(vuln_data.get('Critical', 0))
        high = int(vuln_data.get('High', 0))
        medium = int(vuln_data.get('Medium', 0))
        low = int(vuln_data.get('Low', 0))

        # Weighted risk score
        risk_score = (critical * 10) + (high * 7) + (medium * 4) + (low * 1)
        return risk_score

    def generate_inventory_report(self, assets):
        """Generate comprehensive asset inventory report"""
        report = {
            'summary': {
                'total_assets': len(assets),
                'high_risk_assets': len([a for a in assets if a['risk_score'] > 50]),
                'critical_vulnerabilities': sum(a['critical_vulns'] for a in assets),
                'total_vulnerabilities': sum(
                    a['critical_vulns'] + a['high_vulns'] +
                    a['medium_vulns'] + a['low_vulns'] for a in assets
                )
            },
            'assets': assets
        }

        return report

# Usage example
if __name__ == "__main__":
    # Initialize Tenable manager
    manager = TenableAssetManager(
        access_key="your_access_key",
        secret_key="your_secret_key"
    )

    # Discover assets in network range
    network_range = "192.168.1.0/24,10.0.0.0/16"
    scan_id = manager.discover_assets(network_range)

    if scan_id:
        # Launch scan
        manager.launch_scan(scan_id)

        # Wait for completion (implement polling logic)
        # ... polling code ...

        # Export and download results
        export_uuid = manager.export_assets(scan_id)
        if export_uuid:
            csv_file = manager.download_report(scan_id, export_uuid)
            if csv_file:
                # Create structured inventory
                assets = manager.create_asset_inventory(csv_file)
                report = manager.generate_inventory_report(assets)

                print(f"\nAsset Inventory Summary:")
                print(f"Total Assets: {report['summary']['total_assets']}")
                print(f"High Risk Assets: {report['summary']['high_risk_assets']}")
                print(f"Critical Vulnerabilities: {report['summary']['critical_vulnerabilities']}")
```

**2. Vulnerability Assessment Automation:**
```python
#!/usr/bin/env python3
"""
Automated Vulnerability Assessment Pipeline
Comprehensive scanning and analysis workflow
"""

import requests
import time
import json
from datetime import datetime, timedelta

class VulnerabilityAssessment:
    def __init__(self, tenable_manager):
        self.tenable = tenable_manager
        self.scan_templates = {
            'discovery': '731a8e52-3ea6-a291-ec0a-d2ff0619c19d7bd788d6',
            'basic_scan': 'ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260',
            'credentialed_scan': 'ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260',
            'web_app_scan': 'dd9c4df4-6fef-4b0e-b9ac-13b2f3e5f0be',
            'malware_scan': '8e6a3a8c-1bfa-4b39-9c65-8f4e25f8e5f7'
        }

    def create_comprehensive_scan_policy(self):
        """Create custom scan policy for comprehensive assessment"""
        policy_data = {
            "settings": {
                "name": "Comprehensive Security Assessment",
                "description": "Full vulnerability assessment with credentialed scanning",

                # Network scanning settings
                "discovery_mode": "Port scan (common ports)",
                "port_range": "default",
                "ping_the_remote_host": "yes",
                "tcp_scanning": "yes",
                "udp_scanning": "yes",
                "syn_scanner": "yes",

                # Authentication settings
                "ssh_settings": {
                    "ssh_user": "vuln_scanner",
                    "ssh_password": "scanner_password",
                    "ssh_known_hosts": "",
                    "ssh_port": "22"
                },

                "windows_settings": {
                    "sme_user": "vuln_scanner",
                    "sme_password": "scanner_password",
                    "sme_domain": "LAB.LOCAL"
                },

                # Web application testing
                "webapp_test": "yes",
                "test_default_oracle_accounts": "yes",
                "test_default_mssql_accounts": "yes",

                # Compliance checks
                "enable_plugin_list": [
                    "21156",  # Windows Compliance Checks
                    "21157",  # Unix Compliance Checks
                    "33814",  # Network Compliance Checks
                    "55472"   # Database Compliance Checks
                ],

                # Performance settings
                "max_hosts": "100",
                "max_checks": "5",
                "network_receive_timeout": "5",
                "checks_read_timeout": "5"
            }
        }

        return policy_data

    def execute_phased_assessment(self, target_groups):
        """Execute vulnerability assessment in phases"""
        assessment_results = {
            'scan_ids': [],
            'phases': [],
            'start_time': datetime.now(),
            'status': 'running'
        }

        # Phase 1: Network Discovery
        print("[Phase 1] Network Discovery and Asset Inventory")
        discovery_targets = []
        for group in target_groups:
            discovery_targets.extend(group['targets'])

        discovery_scan = self.tenable.discover_assets(','.join(discovery_targets))
        if discovery_scan:
            assessment_results['scan_ids'].append(discovery_scan)
            assessment_results['phases'].append({
                'phase': 'discovery',
                'scan_id': discovery_scan,
                'status': 'running',
                'start_time': datetime.now()
            })

        # Wait for discovery to complete
        self.wait_for_scan_completion(discovery_scan)

        # Phase 2: Credentialed Vulnerability Scanning
        print("[Phase 2] Credentialed Vulnerability Scanning")
        for group in target_groups:
            if group['type'] == 'critical_systems':
                # Use comprehensive credentialed scanning
                scan_data = {
                    "uuid": self.scan_templates['credentialed_scan'],
                    "settings": {
                        "name": f"Credentialed Scan - {group['name']}",
                        "text_targets": ','.join(group['targets']),
                        "launch": "ONETIME"
                    }
                }
            else:
                # Use basic scanning for non-critical systems
                scan_data = {
                    "uuid": self.scan_templates['basic_scan'],
                    "settings": {
                        "name": f"Basic Scan - {group['name']}",
                        "text_targets": ','.join(group['targets']),
                        "launch": "ONETIME"
                    }
                }

            scan_id = self.create_and_launch_scan(scan_data)
            if scan_id:
                assessment_results['scan_ids'].append(scan_id)
                assessment_results['phases'].append({
                    'phase': f'vulnerability_scan_{group["name"]}',
                    'scan_id': scan_id,
                    'status': 'running',
                    'start_time': datetime.now()
                })

        # Phase 3: Web Application Testing (if applicable)
        web_targets = [group for group in target_groups if group['type'] == 'web_applications']
        if web_targets:
            print("[Phase 3] Web Application Security Testing")
            for group in web_targets:
                scan_data = {
                    "uuid": self.scan_templates['web_app_scan'],
                    "settings": {
                        "name": f"Web App Scan - {group['name']}",
                        "text_targets": ','.join(group['targets']),
                        "launch": "ONETIME"
                    }
                }

                scan_id = self.create_and_launch_scan(scan_data)
                if scan_id:
                    assessment_results['scan_ids'].append(scan_id)
                    assessment_results['phases'].append({
                        'phase': f'web_app_scan_{group["name"]}',
                        'scan_id': scan_id,
                        'status': 'running',
                        'start_time': datetime.now()
                    })

        return assessment_results

    def create_and_launch_scan(self, scan_data):
        """Create and launch a scan"""
        response = requests.post(
            f"{self.tenable.base_url}/scans",
            headers=self.tenable.headers,
            json=scan_data
        )

        if response.status_code == 200:
            scan_id = response.json()['scan']['id']

            # Launch the scan
            launch_response = requests.post(
                f"{self.tenable.base_url}/scans/{scan_id}/launch",
                headers=self.tenable.headers
            )

            if launch_response.status_code == 200:
                print(f"Scan launched successfully: {scan_id}")
                return scan_id
            else:
                print(f"Error launching scan: {launch_response.text}")
                return None
        else:
            print(f"Error creating scan: {response.text}")
            return None

    def wait_for_scan_completion(self, scan_id, timeout_hours=6):
        """Wait for scan to complete with timeout"""
        start_time = datetime.now()
        timeout = timedelta(hours=timeout_hours)

        while datetime.now() - start_time < timeout:
            status = self.tenable.get_scan_status(scan_id)

            if status == 'completed':
                print(f"Scan {scan_id} completed successfully")
                return True
            elif status in ['canceled', 'aborted']:
                print(f"Scan {scan_id} was {status}")
                return False

            print(f"Scan {scan_id} status: {status}")
            time.sleep(300)  # Check every 5 minutes

        print(f"Scan {scan_id} timed out after {timeout_hours} hours")
        return False

    def analyze_vulnerabilities(self, scan_id):
        """Analyze vulnerabilities from completed scan"""
        # Get scan results
        response = requests.get(
            f"{self.tenable.base_url}/scans/{scan_id}",
            headers=self.tenable.headers
        )

        if response.status_code != 200:
            print(f"Error retrieving scan results: {response.text}")
            return None

        scan_data = response.json()
        vulnerabilities = []

        # Process vulnerability data
        for host in scan_data.get('hosts', []):
            host_ip = host['hostname']

            # Get detailed vulnerability info for each host
            host_response = requests.get(
                f"{self.tenable.base_url}/scans/{scan_id}/hosts/{host['host_id']}",
                headers=self.tenable.headers
            )

            if host_response.status_code == 200:
                host_data = host_response.json()

                for vuln in host_data.get('vulnerabilities', []):
                    vuln_detail = {
                        'host': host_ip,
                        'plugin_id': vuln['plugin_id'],
                        'plugin_name': vuln['plugin_name'],
                        'severity': vuln['severity'],
                        'count': vuln['count']
                    }
                    vulnerabilities.append(vuln_detail)

        return vulnerabilities

    def prioritize_vulnerabilities(self, vulnerabilities):
        """Prioritize vulnerabilities based on multiple factors"""
        prioritized = []

        for vuln in vulnerabilities:
            # Get detailed vulnerability information
            vuln_details = self.get_vulnerability_details(vuln['plugin_id'])

            if vuln_details:
                # Calculate priority score
                priority_score = self.calculate_priority_score(
                    vuln_details, vuln['severity'], vuln['host']
                )

                prioritized_vuln = {
                    **vuln,
                    'cvss_score': vuln_details.get('cvss_base_score', 0),
                    'exploitability': vuln_details.get('exploitability_ease', 'Unknown'),
                    'patch_available': vuln_details.get('patch_publication_date', None),
                    'priority_score': priority_score,
                    'business_impact': self.assess_business_impact(vuln['host'])
                }

                prioritized.append(prioritized_vuln)

        # Sort by priority score (highest first)
        prioritized.sort(key=lambda x: x['priority_score'], reverse=True)
        return prioritized

    def calculate_priority_score(self, vuln_details, severity, host):
        """Calculate vulnerability priority score"""
        score = 0

        # Base score from CVSS
        cvss_score = float(vuln_details.get('cvss_base_score', 0))
        score += cvss_score * 10

        # Severity multiplier
        severity_multipliers = {
            4: 3.0,  # Critical
            3: 2.5,  # High
            2: 1.5,  # Medium
            1: 1.0,  # Low
            0: 0.5   # Info
        }
        score *= severity_multipliers.get(severity, 1.0)

        # Exploitability factor
        exploitability = vuln_details.get('exploitability_ease', '').lower()
        if 'exploit available' in exploitability:
            score *= 2.0
        elif 'proof of concept' in exploitability:
            score *= 1.5

        # Asset criticality (determine based on host characteristics)
        asset_criticality = self.get_asset_criticality(host)
        score *= asset_criticality

        # Patch availability (older vulnerabilities with patches get higher priority)
        patch_date = vuln_details.get('patch_publication_date')
        if patch_date:
            # Increase priority for older patches not yet applied
            days_since_patch = (datetime.now() - datetime.strptime(patch_date, '%Y/%m/%d')).days
            if days_since_patch > 30:
                score *= 1.3

        return round(score, 2)

    def get_asset_criticality(self, host_ip):
        """Determine asset criticality based on host characteristics"""
        # This would typically integrate with CMDB or asset management system
        # For demo purposes, using IP-based logic

        if host_ip.startswith('192.168.1.'):  # Domain controllers
            return 3.0
        elif host_ip.startswith('192.168.2.'):  # Servers
            return 2.5
        elif host_ip.startswith('192.168.3.'):  # Workstations
            return 1.5
        else:
            return 1.0

# Usage example
target_groups = [
    {
        'name': 'domain_controllers',
        'type': 'critical_systems',
        'targets': ['192.168.1.10', '192.168.1.11']
    },
    {
        'name': 'web_servers',
        'type': 'web_applications',
        'targets': ['192.168.2.20', '192.168.2.21']
    },
    {
        'name': 'workstations',
        'type': 'endpoints',
        'targets': ['192.168.3.0/24']
    }
]

# Initialize assessment
assessment = VulnerabilityAssessment(manager)
results = assessment.execute_phased_assessment(target_groups)

print(f"Assessment initiated with {len(results['scan_ids'])} scans")
```

## Cyber Range Environment

### LogicGate Pacific Cyber Range

**Caracter√≠sticas do Ambiente:**
```
üèóÔ∏è Infrastructure:
   - Microsoft Azure Cloud
   - Live Windows Servers
   - Real attack scenarios
   - Tenable vulnerability scanning
   - Hands-on remediation

üéØ Learning Objectives:
   - Tenable platform mastery
   - Vulnerability assessment methodology
   - Risk prioritization
   - Remediation planning
   - Reporting and communication

üìö Training Components:
   - Video lectures
   - Hands-on laboratories
   - Real-world scenarios
   - Threat hunting exercises
   - Incident response practice
```

**Laborat√≥rios Pr√°ticos:**

**1. Environment Setup and Configuration:**
```bash
# Azure resource provisioning script
# setup_cyber_range.sh

#!/bin/bash

# Variables
RESOURCE_GROUP="CyberRange-RG"
LOCATION="East US"
VNET_NAME="CyberRange-VNet"
SUBNET_NAME="Internal-Subnet"

# Create resource group
az group create --name $RESOURCE_GROUP --location "$LOCATION"

# Create virtual network
az network vnet create \
    --resource-group $RESOURCE_GROUP \
    --name $VNET_NAME \
    --address-prefix 10.0.0.0/16 \
    --subnet-name $SUBNET_NAME \
    --subnet-prefix 10.0.1.0/24

# Create network security group
az network nsg create \
    --resource-group $RESOURCE_GROUP \
    --name CyberRange-NSG

# Create vulnerable Windows Server 2019
az vm create \
    --resource-group $RESOURCE_GROUP \
    --name VulnServer01 \
    --image MicrosoftWindowsServer:WindowsServer:2019-Datacenter:latest \
    --admin-username vulnadmin \
    --admin-password 'P@ssw0rd123!' \
    --vnet-name $VNET_NAME \
    --subnet $SUBNET_NAME \
    --nsg CyberRange-NSG \
    --size Standard_B2s

# Create additional vulnerable systems
az vm create \
    --resource-group $RESOURCE_GROUP \
    --name VulnServer02 \
    --image MicrosoftWindowsServer:WindowsServer:2016-Datacenter:latest \
    --admin-username vulnadmin \
    --admin-password 'P@ssw0rd123!' \
    --vnet-name $VNET_NAME \
    --subnet $SUBNET_NAME \
    --nsg CyberRange-NSG \
    --size Standard_B2s

# Create Ubuntu server with vulnerabilities
az vm create \
    --resource-group $RESOURCE_GROUP \
    --name VulnUbuntu01 \
    --image Canonical:UbuntuServer:18.04-LTS:latest \
    --admin-username vulnadmin \
    --admin-password 'P@ssw0rd123!' \
    --vnet-name $VNET_NAME \
    --subnet $SUBNET_NAME \
    --nsg CyberRange-NSG \
    --size Standard_B2s \
    --authentication-type password

echo "Cyber Range environment created successfully"
echo "Configure Tenable scanners to target the created VMs"
```

**2. Vulnerability Injection Scripts:**
```powershell
# PowerShell script to create vulnerable configurations
# Create_Vulnerabilities.ps1

Write-Host "[+] Creating Vulnerable Configurations for Testing"

# Disable Windows Defender (creates vulnerability)
Write-Host "    [>] Disabling Windows Defender"
Set-MpPreference -DisableRealtimeMonitoring $true
Set-MpPreference -DisableBehaviorMonitoring $true

# Install outdated software versions
Write-Host "    [>] Installing outdated software"

# Install old Java version (known vulnerabilities)
$javaUrl = "https://javadl.oracle.com/webapps/download/AutoDL?BundleId=240728_5b13a193868b4bf28bcb45c792fce896"
Invoke-WebRequest -Uri $javaUrl -OutFile "C:\temp\java_old.exe"
Start-Process -FilePath "C:\temp\java_old.exe" -ArgumentList "/s" -Wait

# Install Adobe Flash (deprecated, vulnerable)
$flashUrl = "https://fpdownload.adobe.com/get/flashplayer/pdc/32.0.0.465/install_flash_player_ax.exe"
Invoke-WebRequest -Uri $flashUrl -OutFile "C:\temp\flash.exe"
Start-Process -FilePath "C:\temp\flash.exe" -ArgumentList "/install" -Wait

# Create weak service configurations
Write-Host "    [>] Creating weak service configurations"

# Create service with weak permissions
sc.exe create "VulnService" binpath= "C:\Windows\System32\svchost.exe" start= auto
sc.exe sdset "VulnService" "D:(A;;CCLCSWRPWPDTLOCRRC;;;WD)"

# Configure weak registry permissions
$regPath = "HKLM:\SOFTWARE\VulnApp"
New-Item -Path $regPath -Force
$acl = Get-Acl $regPath
$accessRule = New-Object System.Security.AccessControl.RegistryAccessRule("Everyone","FullControl","Allow")
$acl.SetAccessRule($accessRule)
$acl | Set-Acl -Path $regPath

# Create files with weak permissions
Write-Host "    [>] Creating files with weak permissions"
$vulnFile = "C:\Program Files\VulnApp\config.txt"
New-Item -ItemType Directory -Path "C:\Program Files\VulnApp" -Force
"admin_password=password123" | Out-File -FilePath $vulnFile
$acl = Get-Acl $vulnFile
$accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule("Everyone","FullControl","Allow")
$acl.SetAccessRule($accessRule)
$acl | Set-Acl -Path $vulnFile

# Disable automatic updates
Write-Host "    [>] Disabling automatic updates"
Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update" -Name "AUOptions" -Value 1

# Configure weak password policy
Write-Host "    [>] Configuring weak password policy"
secedit /export /cfg c:\temp\secpol.cfg
(Get-Content c:\temp\secpol.cfg) -replace "MinimumPasswordLength = .*", "MinimumPasswordLength = 1" | Set-Content c:\temp\secpol.cfg
(Get-Content c:\temp\secpol.cfg) -replace "PasswordComplexity = .*", "PasswordComplexity = 0" | Set-Content c:\temp\secpol.cfg
secedit /configure /db c:\windows\security\local.sdb /cfg c:\temp\secpol.cfg

# Install vulnerable web application (DVWA-like)
Write-Host "    [>] Installing vulnerable web application"
# Install IIS
Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServerRole, IIS-WebServer, IIS-CommonHttpFeatures, IIS-HttpErrors, IIS-HttpRedirect, IIS-ApplicationDevelopment, IIS-ASPNET45

# Create vulnerable PHP application
$phpCode = @"
<?php
// Vulnerable login page
if (\$_POST['username'] && \$_POST['password']) {
    // SQL Injection vulnerability
    \$query = "SELECT * FROM users WHERE username='" . \$_POST['username'] . "' AND password='" . \$_POST['password'] . "'";

    // Command injection vulnerability
    system("ping " . \$_POST['hostname']);

    // XSS vulnerability
    echo "Welcome " . \$_POST['username'];
}
?>
<form method="POST">
    Username: <input type="text" name="username"><br>
    Password: <input type="password" name="password"><br>
    Hostname: <input type="text" name="hostname"><br>
    <input type="submit" value="Login">
</form>
"@

$phpCode | Out-File -FilePath "C:\inetpub\wwwroot\login.php" -Encoding UTF8

Write-Host "[‚úì] Vulnerable configuration complete"
Write-Host "    - Disabled Windows Defender"
Write-Host "    - Installed outdated software"
Write-Host "    - Created weak service permissions"
Write-Host "    - Configured weak password policy"
Write-Host "    - Installed vulnerable web application"
Write-Host ""
Write-Host "[!] This system is now INTENTIONALLY VULNERABLE"
Write-Host "[!] Use only for educational/testing purposes"
```

## Metodologia de Vulnerability Assessment

### Processo Sistem√°tico

**1. Pre-Assessment Phase:**
```
üìã Scope Definition:
   - Asset inventory
   - Network boundaries
   - Compliance requirements
   - Business criticality assessment

üîê Access Preparation:
   - Credential gathering
   - Permission validation
   - Scanner deployment
   - Network access verification

üìÖ Timeline Planning:
   - Scan windows
   - Maintenance schedules
   - Business impact assessment
   - Resource allocation
```

**2. Assessment Execution:**
```python
#!/usr/bin/env python3
"""
Comprehensive Vulnerability Assessment Methodology
Step-by-step assessment execution
"""

class VulnAssessmentMethodology:
    def __init__(self):
        self.phases = [
            'reconnaissance',
            'discovery',
            'enumeration',
            'vulnerability_identification',
            'validation',
            'risk_assessment',
            'reporting'
        ]
        self.current_phase = 0

    def phase_1_reconnaissance(self, target_scope):
        """Phase 1: Information Gathering and Reconnaissance"""
        print("[Phase 1] Reconnaissance and Information Gathering")

        recon_results = {
            'dns_information': self.gather_dns_info(target_scope),
            'whois_data': self.gather_whois_data(target_scope),
            'public_information': self.gather_osint(target_scope),
            'network_topology': self.map_network_topology(target_scope)
        }

        return recon_results

    def gather_dns_info(self, domain):
        """Gather DNS information"""
        import dns.resolver

        dns_info = {
            'a_records': [],
            'mx_records': [],
            'ns_records': [],
            'txt_records': []
        }

        try:
            # A records
            answers = dns.resolver.resolve(domain, 'A')
            dns_info['a_records'] = [str(rdata) for rdata in answers]

            # MX records
            answers = dns.resolver.resolve(domain, 'MX')
            dns_info['mx_records'] = [str(rdata) for rdata in answers]

            # NS records
            answers = dns.resolver.resolve(domain, 'NS')
            dns_info['ns_records'] = [str(rdata) for rdata in answers]

            # TXT records
            answers = dns.resolver.resolve(domain, 'TXT')
            dns_info['txt_records'] = [str(rdata) for rdata in answers]

        except Exception as e:
            print(f"DNS lookup error: {e}")

        return dns_info

    def phase_2_discovery(self, target_networks):
        """Phase 2: Asset Discovery and Port Scanning"""
        print("[Phase 2] Asset Discovery and Service Enumeration")

        import nmap
        nm = nmap.PortScanner()

        discovered_assets = []

        for network in target_networks:
            print(f"    [>] Scanning network: {network}")

            # Host discovery
            nm.scan(hosts=network, arguments='-sn')
            live_hosts = nm.all_hosts()

            for host in live_hosts:
                # Port scanning
                nm.scan(host, '1-65535', '-sV -sC --script vuln')

                host_info = {
                    'ip': host,
                    'hostname': nm[host].hostname(),
                    'state': nm[host].state(),
                    'ports': [],
                    'os_detection': nm[host].get('osmatch', []),
                    'vulnerabilities': []
                }

                # Extract port information
                for protocol in nm[host].all_protocols():
                    ports = nm[host][protocol].keys()
                    for port in ports:
                        port_info = nm[host][protocol][port]
                        host_info['ports'].append({
                            'port': port,
                            'protocol': protocol,
                            'state': port_info['state'],
                            'service': port_info.get('name', 'unknown'),
                            'version': port_info.get('version', 'unknown'),
                            'product': port_info.get('product', 'unknown')
                        })

                # Extract vulnerability information from scripts
                if 'script' in nm[host]:
                    for script_name, script_output in nm[host]['script'].items():
                        if 'vuln' in script_name.lower():
                            host_info['vulnerabilities'].append({
                                'script': script_name,
                                'output': script_output
                            })

                discovered_assets.append(host_info)

        return discovered_assets

    def phase_3_vulnerability_identification(self, assets):
        """Phase 3: Detailed Vulnerability Identification"""
        print("[Phase 3] Vulnerability Identification and Analysis")

        all_vulnerabilities = []

        for asset in assets:
            print(f"    [>] Analyzing {asset['ip']}")

            # Service-specific vulnerability checks
            for port_info in asset['ports']:
                service = port_info['service']
                version = port_info['version']

                # Check for known vulnerable services
                vulns = self.check_service_vulnerabilities(service, version)

                for vuln in vulns:
                    vuln['host'] = asset['ip']
                    vuln['port'] = port_info['port']
                    vuln['service'] = service
                    all_vulnerabilities.append(vuln)

            # Check for configuration vulnerabilities
            config_vulns = self.check_configuration_vulnerabilities(asset)
            all_vulnerabilities.extend(config_vulns)

        return all_vulnerabilities

    def check_service_vulnerabilities(self, service, version):
        """Check for known vulnerabilities in specific services"""
        vulnerabilities = []

        # Example vulnerability database (in reality, use CVE database)
        vuln_db = {
            'ssh': {
                'OpenSSH 7.4': [
                    {
                        'cve': 'CVE-2018-15473',
                        'description': 'OpenSSH Username Enumeration',
                        'severity': 'Medium',
                        'cvss_score': 5.3
                    }
                ]
            },
            'http': {
                'Apache 2.4.7': [
                    {
                        'cve': 'CVE-2017-7679',
                        'description': 'Apache HTTP Server mod_mime Buffer Overflow',
                        'severity': 'High',
                        'cvss_score': 7.5
                    }
                ]
            },
            'mysql': {
                'MySQL 5.7.21': [
                    {
                        'cve': 'CVE-2018-2817',
                        'description': 'MySQL Server DDL Vulnerability',
                        'severity': 'Medium',
                        'cvss_score': 4.9
                    }
                ]
            }
        }

        if service in vuln_db and version in vuln_db[service]:
            vulnerabilities = vuln_db[service][version]

        return vulnerabilities

    def phase_4_risk_assessment(self, vulnerabilities):
        """Phase 4: Risk Assessment and Prioritization"""
        print("[Phase 4] Risk Assessment and Prioritization")

        for vuln in vulnerabilities:
            # Calculate risk score
            vuln['risk_score'] = self.calculate_comprehensive_risk_score(vuln)

            # Assign risk level
            vuln['risk_level'] = self.assign_risk_level(vuln['risk_score'])

            # Add business impact assessment
            vuln['business_impact'] = self.assess_business_impact(vuln)

            # Add remediation priority
            vuln['remediation_priority'] = self.calculate_remediation_priority(vuln)

        # Sort by risk score
        vulnerabilities.sort(key=lambda x: x['risk_score'], reverse=True)

        return vulnerabilities

    def calculate_comprehensive_risk_score(self, vuln):
        """Calculate comprehensive risk score"""
        base_score = vuln.get('cvss_score', 5.0)

        # Asset criticality multiplier
        asset_criticality = self.get_asset_criticality(vuln['host'])

        # Threat intelligence factor
        threat_intel_factor = self.get_threat_intelligence_factor(vuln.get('cve'))

        # Exploit availability factor
        exploit_factor = self.get_exploit_availability_factor(vuln.get('cve'))

        # Calculate final risk score
        risk_score = base_score * asset_criticality * threat_intel_factor * exploit_factor

        return min(risk_score, 10.0)  # Cap at 10.0

    def generate_comprehensive_report(self, vulnerabilities, assets):
        """Generate comprehensive vulnerability assessment report"""
        report = {
            'executive_summary': self.generate_executive_summary(vulnerabilities),
            'technical_findings': self.generate_technical_findings(vulnerabilities),
            'risk_analysis': self.generate_risk_analysis(vulnerabilities),
            'remediation_plan': self.generate_remediation_plan(vulnerabilities),
            'appendices': {
                'asset_inventory': assets,
                'vulnerability_details': vulnerabilities,
                'scanning_methodology': self.get_methodology_details()
            }
        }

        return report

# Usage example
methodology = VulnAssessmentMethodology()

# Execute assessment
target_scope = ['example.com']
target_networks = ['192.168.1.0/24', '10.0.0.0/24']

recon_results = methodology.phase_1_reconnaissance(target_scope)
discovered_assets = methodology.phase_2_discovery(target_networks)
vulnerabilities = methodology.phase_3_vulnerability_identification(discovered_assets)
risk_assessed_vulns = methodology.phase_4_risk_assessment(vulnerabilities)

# Generate final report
final_report = methodology.generate_comprehensive_report(risk_assessed_vulns, discovered_assets)

print(f"Assessment complete: {len(risk_assessed_vulns)} vulnerabilities identified")
print(f"High risk vulnerabilities: {len([v for v in risk_assessed_vulns if v['risk_level'] == 'High'])}")
```

## Relat√≥rios e M√©tricas

### Executive Dashboard

```python
#!/usr/bin/env python3
"""
Vulnerability Management Dashboard
Executive and technical reporting
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from datetime import datetime, timedelta

class VulnManagementDashboard:
    def __init__(self, vulnerability_data):
        self.vuln_data = vulnerability_data
        self.df = pd.DataFrame(vulnerability_data)

    def generate_executive_dashboard(self):
        """Generate executive-level dashboard"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('Vulnerability Management Executive Dashboard', fontsize=16)

        # 1. Risk Distribution Pie Chart
        risk_counts = self.df['risk_level'].value_counts()
        colors = ['#ff4444', '#ff8800', '#ffbb00', '#44ff44']
        axes[0, 0].pie(risk_counts.values, labels=risk_counts.index, autopct='%1.1f%%', colors=colors)
        axes[0, 0].set_title('Risk Distribution')

        # 2. Vulnerabilities by Asset Type
        asset_vulns = self.df.groupby('asset_type')['risk_score'].count().sort_values(ascending=False)
        axes[0, 1].bar(asset_vulns.index, asset_vulns.values, color='steelblue')
        axes[0, 1].set_title('Vulnerabilities by Asset Type')
        axes[0, 1].tick_params(axis='x', rotation=45)

        # 3. CVSS Score Distribution
        axes[1, 0].hist(self.df['cvss_score'], bins=20, color='lightcoral', alpha=0.7)
        axes[1, 0].set_title('CVSS Score Distribution')
        axes[1, 0].set_xlabel('CVSS Score')
        axes[1, 0].set_ylabel('Count')

        # 4. Top 10 Vulnerability Types
        vuln_types = self.df['vulnerability_type'].value_counts().head(10)
        axes[1, 1].barh(range(len(vuln_types)), vuln_types.values, color='lightgreen')
        axes[1, 1].set_yticks(range(len(vuln_types)))
        axes[1, 1].set_yticklabels(vuln_types.index)
        axes[1, 1].set_title('Top 10 Vulnerability Types')

        plt.tight_layout()
        plt.savefig('executive_dashboard.png', dpi=300, bbox_inches='tight')
        plt.show()

    def generate_technical_report(self):
        """Generate detailed technical report"""
        report = {
            'summary_statistics': self.calculate_summary_stats(),
            'risk_analysis': self.perform_risk_analysis(),
            'trending_data': self.analyze_trends(),
            'remediation_metrics': self.calculate_remediation_metrics()
        }

        return report

    def calculate_summary_stats(self):
        """Calculate key summary statistics"""
        stats = {
            'total_vulnerabilities': len(self.df),
            'critical_count': len(self.df[self.df['risk_level'] == 'Critical']),
            'high_count': len(self.df[self.df['risk_level'] == 'High']),
            'medium_count': len(self.df[self.df['risk_level'] == 'Medium']),
            'low_count': len(self.df[self.df['risk_level'] == 'Low']),
            'average_cvss': self.df['cvss_score'].mean(),
            'unique_assets_affected': self.df['host'].nunique(),
            'most_vulnerable_asset': self.df['host'].value_counts().index[0] if not self.df.empty else None
        }

        return stats

    def generate_remediation_dashboard(self):
        """Generate remediation tracking dashboard"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('Vulnerability Remediation Tracking', fontsize=16)

        # 1. Remediation Status
        if 'remediation_status' in self.df.columns:
            status_counts = self.df['remediation_status'].value_counts()
            axes[0, 0].pie(status_counts.values, labels=status_counts.index, autopct='%1.1f%%')
            axes[0, 0].set_title('Remediation Status')

        # 2. Time to Remediation
        if 'time_to_remediation' in self.df.columns:
            remediated = self.df[self.df['remediation_status'] == 'Remediated']
            axes[0, 1].hist(remediated['time_to_remediation'], bins=15, color='lightblue')
            axes[0, 1].set_title('Time to Remediation (Days)')
            axes[0, 1].set_xlabel('Days')

        # 3. SLA Compliance
        if 'sla_breach' in self.df.columns:
            sla_compliance = self.df['sla_breach'].value_counts()
            axes[1, 0].bar(sla_compliance.index, sla_compliance.values, color=['green', 'red'])
            axes[1, 0].set_title('SLA Compliance')

        # 4. Remediation by Team
        if 'responsible_team' in self.df.columns:
            team_remediation = self.df.groupby('responsible_team')['remediation_status'].apply(
                lambda x: (x == 'Remediated').sum()
            ).sort_values(ascending=False)
            axes[1, 1].bar(team_remediation.index, team_remediation.values, color='orange')
            axes[1, 1].set_title('Remediation by Team')
            axes[1, 1].tick_params(axis='x', rotation=45)

        plt.tight_layout()
        plt.savefig('remediation_dashboard.png', dpi=300, bbox_inches='tight')
        plt.show()

    def export_reports(self, format='html'):
        """Export reports in various formats"""
        if format == 'html':
            self.export_html_report()
        elif format == 'pdf':
            self.export_pdf_report()
        elif format == 'excel':
            self.export_excel_report()

    def export_html_report(self):
        """Export comprehensive HTML report"""
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Vulnerability Assessment Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .header { background-color: #2c3e50; color: white; padding: 20px; text-align: center; }
                .summary-box { background-color: #ecf0f1; padding: 15px; margin: 20px 0; border-radius: 5px; }
                .critical { color: #e74c3c; font-weight: bold; }
                .high { color: #f39c12; font-weight: bold; }
                .medium { color: #f1c40f; font-weight: bold; }
                .low { color: #27ae60; font-weight: bold; }
                table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                th, td { border: 1px solid #bdc3c7; padding: 8px; text-align: left; }
                th { background-color: #34495e; color: white; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Vulnerability Assessment Report</h1>
                <p>Generated on: {date}</p>
            </div>

            <div class="summary-box">
                <h2>Executive Summary</h2>
                <p>Total Vulnerabilities: <strong>{total_vulns}</strong></p>
                <p><span class="critical">Critical: {critical_count}</span> |
                   <span class="high">High: {high_count}</span> |
                   <span class="medium">Medium: {medium_count}</span> |
                   <span class="low">Low: {low_count}</span></p>
                <p>Assets Affected: <strong>{unique_assets}</strong></p>
                <p>Average CVSS Score: <strong>{avg_cvss:.2f}</strong></p>
            </div>

            <h2>Top Critical Vulnerabilities</h2>
            <table>
                <thead>
                    <tr>
                        <th>Host</th>
                        <th>Vulnerability</th>
                        <th>CVSS Score</th>
                        <th>Risk Level</th>
                        <th>CVE</th>
                    </tr>
                </thead>
                <tbody>
                    {critical_vulns_table}
                </tbody>
            </table>

            <h2>Recommendations</h2>
            <div class="summary-box">
                <ol>
                    <li>Immediately patch all critical vulnerabilities</li>
                    <li>Implement network segmentation for high-risk assets</li>
                    <li>Deploy additional monitoring for affected systems</li>
                    <li>Conduct penetration testing to validate fixes</li>
                    <li>Implement vulnerability management program</li>
                </ol>
            </div>
        </body>
        </html>
        """

        # Get summary statistics
        stats = self.calculate_summary_stats()

        # Get critical vulnerabilities for table
        critical_vulns = self.df[self.df['risk_level'] == 'Critical'].head(10)
        critical_table_rows = ""
        for _, vuln in critical_vulns.iterrows():
            critical_table_rows += f"""
                <tr>
                    <td>{vuln['host']}</td>
                    <td>{vuln['vulnerability_name']}</td>
                    <td>{vuln['cvss_score']}</td>
                    <td class="critical">{vuln['risk_level']}</td>
                    <td>{vuln.get('cve', 'N/A')}</td>
                </tr>
            """

        # Format HTML
        html_content = html_template.format(
            date=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            total_vulns=stats['total_vulnerabilities'],
            critical_count=stats['critical_count'],
            high_count=stats['high_count'],
            medium_count=stats['medium_count'],
            low_count=stats['low_count'],
            unique_assets=stats['unique_assets_affected'],
            avg_cvss=stats['average_cvss'],
            critical_vulns_table=critical_table_rows
        )

        # Save to file
        with open('vulnerability_report.html', 'w') as f:
            f.write(html_content)

        print("HTML report generated: vulnerability_report.html")

# Example usage
sample_vuln_data = [
    {
        'host': '192.168.1.10',
        'vulnerability_name': 'Windows SMB RCE',
        'cve': 'CVE-2017-0144',
        'cvss_score': 9.3,
        'risk_level': 'Critical',
        'asset_type': 'Server',
        'vulnerability_type': 'Remote Code Execution',
        'remediation_status': 'Open',
        'discovery_date': '2024-01-15'
    },
    {
        'host': '192.168.1.20',
        'vulnerability_name': 'Apache HTTP Server DoS',
        'cve': 'CVE-2021-44228',
        'cvss_score': 7.5,
        'risk_level': 'High',
        'asset_type': 'Web Server',
        'vulnerability_type': 'Denial of Service',
        'remediation_status': 'In Progress',
        'discovery_date': '2024-01-16'
    }
]

dashboard = VulnManagementDashboard(sample_vuln_data)
dashboard.generate_executive_dashboard()
dashboard.generate_remediation_dashboard()
dashboard.export_html_report()
```

## Documenta√ß√£o de Projetos

### Adi√ß√£o ao Curr√≠culo

```markdown
## PRACTICAL PROJECTS

### Enterprise Vulnerability Management | Tenable Cyber Range
Conducted comprehensive vulnerability assessments using Tenable.io platform in live Azure cloud environment with real attack scenarios and remediation workflows.
- **Platform**: Tenable.io, Azure Cloud, Windows/Linux environments
- **Scope**: 50+ assets scanned, 200+ vulnerabilities identified and prioritized
- **Achievements**: 95% vulnerability detection accuracy, 40% reduction in remediation time
- **Methodologies**: NIST Cybersecurity Framework, CVSS scoring, risk-based prioritization

### Automated Vulnerability Assessment Pipeline | Personal Project
Developed Python-based automation framework for vulnerability scanning, analysis, and reporting with integration to multiple security tools and platforms.
- **Technologies**: Python, Tenable API, Nmap, Custom reporting
- **Features**: Automated scanning, risk prioritization, SLA tracking, executive dashboards
- **Impact**: 70% reduction in manual assessment time, standardized reporting process
- **GitHub**: [vulnerability-assessment-automation](https://github.com/username/vuln-assessment)

### Cyber Range Security Operations | LogicGate Pacific
Participated in hands-on cyber range exercises performing threat hunting, incident response, and live vulnerability remediation in enterprise environment.
- **Activities**: Live threat hunting, incident response, vulnerability remediation
- **Tools**: Tenable, Splunk, Azure, PowerShell, Linux command line
- **Results**: Successfully contained simulated attacks, completed remediation workflows
- **Duration**: 6+ months continuous training and exercises
```

### Template GitHub README

```markdown
# Vulnerability Management Portfolio

## üéØ Project Overview
Comprehensive vulnerability management projects demonstrating end-to-end assessment capabilities, from discovery through remediation, using industry-standard tools and methodologies.

## üèóÔ∏è Portfolio Architecture

### 1. Tenable Cloud Assessment Lab
**Environment**: Azure cloud infrastructure with intentionally vulnerable systems
- **Systems**: Windows Server 2019, Ubuntu 18.04, CentOS 8
- **Tools**: Tenable.io, Nessus scanners, custom Python automation
- **Scope**: 50+ assets, multiple network segments

### 2. Automated Assessment Pipeline
**Framework**: Python-based automation for scalable vulnerability management
- **Components**: Asset discovery, vulnerability scanning, risk analysis, reporting
- **Integrations**: Tenable API, NIST NVD, MITRE CVE database
- **Output**: Executive dashboards, technical reports, remediation workflows

### 3. Compliance Assessment Program
**Standards**: NIST Cybersecurity Framework, CIS Controls, OWASP Top 10
- **Assessments**: Configuration compliance, security controls validation
- **Reporting**: Gap analysis, remediation roadmaps, executive summaries

## üìä Key Achievements

### Assessment Metrics
- **Assets Scanned**: 200+ systems across multiple environments
- **Vulnerabilities Identified**: 1,500+ unique findings
- **Risk Assessment Accuracy**: 95% true positive rate
- **Remediation Tracking**: 40% improvement in closure time

### Automation Impact
- **Time Savings**: 70% reduction in manual assessment effort
- **Standardization**: Consistent methodology across all assessments
- **Scalability**: Framework supports enterprise-scale deployments
- **Accuracy**: Automated prioritization reduces false positives by 60%

## üî¨ Technical Capabilities

### Vulnerability Assessment
```python
# Example: Automated risk scoring algorithm
def calculate_risk_score(vuln_data):
    base_score = vuln_data['cvss_score']
    asset_criticality = get_asset_criticality(vuln_data['host'])
    threat_intel = get_threat_intelligence(vuln_data['cve'])
    exploit_available = check_exploit_availability(vuln_data['cve'])

    risk_score = base_score * asset_criticality * threat_intel * exploit_available
    return min(risk_score, 10.0)
```

### Platform Integration
- **Tenable.io**: Advanced scanning, agent deployment, API automation
- **Qualys VMDR**: Cloud-based scanning, compliance reporting
- **OpenVAS**: Open-source vulnerability assessment
- **Nmap**: Network discovery and service enumeration
- **Custom Tools**: Python scripts for automation and analysis

### Reporting & Analytics
- **Executive Dashboards**: Risk metrics, trend analysis, KPI tracking
- **Technical Reports**: Detailed findings, remediation guidance
- **Compliance Reports**: Regulatory alignment, control validation
- **Custom Analytics**: Risk modeling, predictive analysis

## üìÅ Repository Structure
```
vulnerability-management-portfolio/
‚îú‚îÄ‚îÄ assessments/
‚îÇ   ‚îú‚îÄ‚îÄ tenable-cloud-lab/
‚îÇ   ‚îú‚îÄ‚îÄ compliance-assessments/
‚îÇ   ‚îî‚îÄ‚îÄ automated-scanning/
‚îú‚îÄ‚îÄ automation/
‚îÇ   ‚îú‚îÄ‚îÄ python-scripts/
‚îÇ   ‚îú‚îÄ‚îÄ api-integrations/
‚îÇ   ‚îî‚îÄ‚îÄ reporting-tools/
‚îú‚îÄ‚îÄ reports/
‚îÇ   ‚îú‚îÄ‚îÄ executive-dashboards/
‚îÇ   ‚îú‚îÄ‚îÄ technical-findings/
‚îÇ   ‚îî‚îÄ‚îÄ remediation-plans/
‚îú‚îÄ‚îÄ documentation/
‚îÇ   ‚îú‚îÄ‚îÄ methodologies/
‚îÇ   ‚îú‚îÄ‚îÄ procedures/
‚îÇ   ‚îî‚îÄ‚îÄ lessons-learned/
‚îî‚îÄ‚îÄ tools/
    ‚îú‚îÄ‚îÄ scanner-configs/
    ‚îú‚îÄ‚îÄ custom-scripts/
    ‚îî‚îÄ‚îÄ integration-apis/
```

## üéì Certifications & Training
- **Tenable Certified Security Professional** (In Progress)
- **Qualys VMDR** - Platform training completed
- **NIST Cybersecurity Framework** - Implementation experience
- **Cyber Range Training** - 6+ months hands-on experience

## üìà Future Roadmap
- Integration with SOAR platforms for automated remediation
- Machine learning for vulnerability prioritization
- DevSecOps pipeline integration
- Container and cloud-native security assessments

## üìû Contact
For detailed demonstrations or collaboration opportunities:
- **Email**: vuln.management@example.com
- **LinkedIn**: [linkedin.com/in/vulnerability-manager](https://linkedin.com/in/vulnerability-manager)
- **Portfolio**: [vulnmgmt-portfolio.com](https://vulnmgmt-portfolio.com)
```

Este documento abrangente sobre Vulnerability Management fornece uma base s√≥lida para desenvolver projetos pr√°ticos que demonstram compet√™ncia real na √°rea, essencial para se destacar no mercado de seguran√ßa cibern√©tica.

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Analisar transcri\u00e7\u00e3o do v\u00eddeo sobre projetos de seguran\u00e7a cibern\u00e9tica", "status": "completed", "activeForm": "Analisando transcri\u00e7\u00e3o do v\u00eddeo sobre projetos de seguran\u00e7a cibern\u00e9tica"}, {"content": "Criar documento sobre projetos SOC Analyst", "status": "completed", "activeForm": "Criando documento sobre projetos SOC Analyst"}, {"content": "Criar documento sobre Network Traffic Analysis e Active Directory", "status": "completed", "activeForm": "Criando documento sobre Network Traffic Analysis e Active Directory"}, {"content": "Criar documento sobre Vulnerability Management", "status": "completed", "activeForm": "Criando documento sobre Vulnerability Management"}, {"content": "Criar documento sobre GRC (Governance, Risk and Compliance)", "status": "in_progress", "activeForm": "Criando documento sobre GRC"}, {"content": "Criar documento sobre Cloud Security", "status": "pending", "activeForm": "Criando documento sobre Cloud Security"}, {"content": "Atualizar documento principal de estrat\u00e9gias com foco em seguran\u00e7a", "status": "pending", "activeForm": "Atualizando documento principal de estrat\u00e9gias com foco em seguran\u00e7a"}]